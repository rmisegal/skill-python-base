% =============================================================================
% Appendix I: GateKeeper Implementation Guide
% מדריך מימוש GateKeeper לסוכנים
% Standalone chapter with subfiles support
% =============================================================================

\documentclass[../master/main.tex]{subfiles}

\begin{document}

\chapter*{נספח ט': מדריך מימוש \en{GateKeeper}}
\addcontentsline{toc}{chapter}{נספח ט': מדריך מימוש \en{GateKeeper}}
\renewcommand{\thehebrewsection}{ט.\arabic{hebrewsection}}
\setcounter{hebrewsection}{0}

\par\needspace{5\baselineskip}
\hebrewsection{מבוא}

נספח זה מספק הנחיות מפורטות למימוש תבנית \en{GateKeeper} בסוכני שחקן ושופט. התבנית מגנה על הסוכן מפני חריגה ממגבלות \en{Gmail API} ומפני לולאות אינסופיות.

\par\needspace{4\baselineskip}
\hebrewsubsection{למה הסוכן צריך \en{GateKeeper}?}

\begin{itemize}
    \item \textbf{מגבלות \en{Gmail API}} --- \num{500} הודעות ביום (מומלץ: \num{400})
    \item \textbf{מגבלת קצב} --- \num{500} קריאות \en{API} בדקה
    \item \textbf{מניעת לולאות} --- באג בקוד עלול לשלוח מאות הודעות בדקות
    \item \textbf{הגנה עצמית} --- הסוכן עלול ``לתקוף'' את עצמו בטעות
\end{itemize}

\begin{warningbox}[\hebtitle{חובת מימוש}]
מימוש \en{GateKeeper} הוא \textbf{חובה} בפרויקט. סוכן שחורג ממגבלות עלול להיחסם על ידי \en{Google} ולפגוע בציון.
\end{warningbox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{רכיבי ה-\en{GateKeeper}}
\label{sec:gatekeeper-components}
% =============================================================================

תבנית \en{GateKeeper} מורכבת משלושה רכיבים עיקריים:

\begin{fancytable}{lH}{רכיבי \en{GateKeeper}}
\label{tab:gatekeeper-components}
רכיב & תפקיד \\
\en{QuotaManager} & ניהול מכסה יומית (\en{400} הודעות) \\
\en{RateLimiter} & הגבלת קצב שליחה (\en{Token Bucket}) \\
\en{DOSDetector} & זיהוי לולאות אינסופיות \\
\end{fancytable}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מימוש \en{QuotaManager}}
\label{sec:quota-manager}
% =============================================================================

מנהל המכסות עוקב אחר מספר ההודעות שנשלחו ביום ומתריע כאשר מתקרבים למגבלה.

\begin{english}
\begin{pythonbox}[\hebtitle{מחלקת \en{QuotaManager}}]
from datetime import datetime, date
from dataclasses import dataclass
import logging

@dataclass
class QuotaState:
    daily_count: int = 0
    last_reset_date: date = None

class QuotaManager:
    """Manages daily email quota to prevent Gmail API limit violations."""

    def __init__(self, daily_limit: int = 400, warning_threshold: float = 0.8):
        self.daily_limit = daily_limit
        self.warning_threshold = warning_threshold
        self.state = QuotaState()
        self.logger = logging.getLogger(__name__)

    def can_send(self) -> bool:
        """Check if we can send another email."""
        self._check_daily_reset()
        return self.state.daily_count < self.daily_limit

    def record_send(self) -> None:
        """Record that an email was sent."""
        self._check_daily_reset()
        self.state.daily_count += 1

        # Warn if approaching limit
        if self.state.daily_count >= self.daily_limit * self.warning_threshold:
            remaining = self.daily_limit - self.state.daily_count
            self.logger.warning(f"Quota warning: {remaining} emails remaining today")

    def _check_daily_reset(self) -> None:
        """Reset counter at midnight."""
        today = date.today()
        if self.state.last_reset_date != today:
            self.state.daily_count = 0
            self.state.last_reset_date = today
            self.logger.info("Daily quota reset")

    def get_remaining(self) -> int:
        """Get number of emails remaining today."""
        self._check_daily_reset()
        return self.daily_limit - self.state.daily_count
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מימוש \en{RateLimiter} (\en{Token Bucket})}
\label{sec:rate-limiter}
% =============================================================================

אלגוריתם \en{Token Bucket} מאפשר שליחה בפרצים תוך שמירה על קצב ממוצע.

\par\needspace{4\baselineskip}
\hebrewsubsection{עקרון הפעולה}

\begin{itemize}
    \item דלי מכיל \en{tokens} (קיבולת מקסימלית)
    \item כל שליחת הודעה צורכת \en{token} אחד
    \item \en{tokens} מתמלאים בקצב קבוע
    \item אם אין \en{tokens}, השליחה נחסמת עד שיהיו
\end{itemize}

\begin{english}
\begin{pythonbox}[\hebtitle{מחלקת \en{TokenBucket}}]
import time
from threading import Lock

class TokenBucket:
    """Token bucket rate limiter for Gmail API calls."""

    def __init__(self, rate: float = 1.0, capacity: int = 10):
        """
        Args:
            rate: Tokens added per second (e.g., 1.0 = 1 token/sec)
            capacity: Maximum tokens in bucket (burst capacity)
        """
        self.rate = rate
        self.capacity = capacity
        self.tokens = capacity
        self.last_refill = time.monotonic()
        self.lock = Lock()

    def acquire(self, tokens: int = 1, blocking: bool = True) -> bool:
        """Acquire tokens, optionally blocking until available."""
        with self.lock:
            self._refill()

            if self.tokens >= tokens:
                self.tokens -= tokens
                return True

            if not blocking:
                return False

            # Calculate wait time
            needed = tokens - self.tokens
            wait_time = needed / self.rate

        # Wait outside lock
        time.sleep(wait_time)

        # Retry after waiting
        with self.lock:
            self._refill()
            if self.tokens >= tokens:
                self.tokens -= tokens
                return True
        return False

    def _refill(self) -> None:
        """Refill tokens based on elapsed time."""
        now = time.monotonic()
        elapsed = now - self.last_refill
        new_tokens = elapsed * self.rate
        self.tokens = min(self.capacity, self.tokens + new_tokens)
        self.last_refill = now
\end{pythonbox}
\end{english}

\begin{fancytable}{lcc}{פרמטרים מומלצים ל-\en{Token Bucket}}
\label{tab:token-bucket-params}
תרחיש & קצב (\en{rate}) & קיבולת (\en{capacity}) \\
פעילות רגילה & \en{1.0} & \en{10} \\
משחק פעיל & \en{2.0} & \en{15} \\
שידורים & \en{0.5} & \en{5} \\
\end{fancytable}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מימוש \en{DOSDetector}}
\label{sec:dos-detector}
% =============================================================================

מזהה דפוסי שליחה חריגים שמעידים על באג או לולאה אינסופית.

\begin{english}
\begin{pythonbox}[\hebtitle{מחלקת \en{DOSDetector}}]
from collections import deque
from datetime import datetime, timedelta
import logging

class DOSDetector:
    """Detects abnormal sending patterns that indicate bugs."""

    def __init__(self, max_per_minute: int = 5, window_seconds: int = 60):
        self.max_per_minute = max_per_minute
        self.window = timedelta(seconds=window_seconds)
        self.send_times: deque[datetime] = deque()
        self.logger = logging.getLogger(__name__)
        self.circuit_open = False

    def record_send(self) -> None:
        """Record a send event and check for DOS pattern."""
        now = datetime.now()
        self.send_times.append(now)
        self._cleanup_old_entries(now)

        if len(self.send_times) > self.max_per_minute:
            self.circuit_open = True
            self.logger.critical(
                f"DOS detected! {len(self.send_times)} sends in {self.window.seconds}s. "
                f"Circuit breaker OPEN."
            )

    def is_blocked(self) -> bool:
        """Check if sending is blocked due to DOS detection."""
        return self.circuit_open

    def reset(self) -> None:
        """Manual reset after fixing the issue."""
        self.circuit_open = False
        self.send_times.clear()
        self.logger.info("DOS detector reset")

    def _cleanup_old_entries(self, now: datetime) -> None:
        """Remove entries outside the time window."""
        cutoff = now - self.window
        while self.send_times and self.send_times[0] < cutoff:
            self.send_times.popleft()
\end{pythonbox}
\end{english}

\begin{warningbox}[{\hebtitle{\en{Circuit Breaker}}}]
כאשר \en{DOSDetector} מזהה דפוס חריג, הוא פותח את ה-\en{Circuit Breaker} וחוסם את כל השליחות. נדרשת התערבות ידנית (או אוטומטית לאחר זמן קירור) לאיפוס.
\end{warningbox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מימוש \en{GateKeeper} המשולב}
\label{sec:integrated-gatekeeper}
% =============================================================================

כעת נשלב את שלושת הרכיבים למחלקה אחת:

\begin{english}
\begin{pythonbox}[\hebtitle{מחלקת \en{GateKeeper} המשולבת}]
class GateKeeper:
    """Combined gate keeper for email sending protection."""

    def __init__(self):
        self.quota = QuotaManager(daily_limit=400)
        self.rate_limiter = TokenBucket(rate=1.0, capacity=10)
        self.dos_detector = DOSDetector(max_per_minute=5)

    def can_send(self) -> tuple[bool, str]:
        """Check all gates before sending."""
        # Check DOS first (highest priority)
        if self.dos_detector.is_blocked():
            return False, "DOS_BLOCKED"

        # Check daily quota
        if not self.quota.can_send():
            return False, "QUOTA_EXCEEDED"

        # Check rate limit (may block)
        if not self.rate_limiter.acquire(blocking=False):
            return False, "RATE_LIMITED"

        return True, "OK"

    def record_send(self) -> None:
        """Record successful send across all components."""
        self.quota.record_send()
        self.dos_detector.record_send()

    def send_email(self, email_func, *args, **kwargs):
        """Wrapper that applies all gates before sending."""
        can_send, reason = self.can_send()
        if not can_send:
            raise GateKeeperBlockedError(reason)

        # Wait for rate limit if needed
        self.rate_limiter.acquire(blocking=True)

        # Send the email
        result = email_func(*args, **kwargs)

        # Record successful send
        self.record_send()
        return result

class GateKeeperBlockedError(Exception):
    """Raised when GateKeeper blocks a send operation."""
    pass
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{שילוב עם סוכן השחקן}
\label{sec:player-integration}
% =============================================================================

\begin{english}
\begin{pythonbox}[\hebtitle{שילוב \en{GateKeeper} בסוכן}]
class PlayerAgent:
    def __init__(self):
        self.gmail_client = GmailClient()
        self.gatekeeper = GateKeeper()

    async def send_message(self, msg: dict) -> bool:
        """Send message through gatekeeper."""
        try:
            return self.gatekeeper.send_email(
                self.gmail_client.send,
                msg
            )
        except GateKeeperBlockedError as e:
            self.logger.error(f"Send blocked: {e}")
            if str(e) == "QUOTA_EXCEEDED":
                # Wait until tomorrow
                await self._wait_for_quota_reset()
            elif str(e) == "DOS_BLOCKED":
                # Alert and halt
                await self._alert_admin("DOS detected!")
                raise
            return False
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{רשימת בדיקה למימוש}
\label{sec:gatekeeper-checklist}
% =============================================================================

\begin{enumerate}
    \item[$\square$] \en{QuotaManager} מותקן עם מגבלה של \num{400} הודעות
    \item[$\square$] \en{TokenBucket} מותקן עם פרמטרים מתאימים
    \item[$\square$] \en{DOSDetector} מותקן עם סף של \num{5} הודעות לדקה
    \item[$\square$] כל שליחת הודעה עוברת דרך \en{GateKeeper}
    \item[$\square$] לוגים מתועדים כאשר מגיעים ל-\num{80}\% מהמכסה
    \item[$\square$] \en{Circuit Breaker} פועל בזיהוי \en{DOS}
    \item[$\square$] קיים מנגנון התאוששות לאחר חסימה
\end{enumerate}

\end{document}
