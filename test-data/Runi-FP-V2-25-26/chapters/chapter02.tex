% =============================================================================
% Chapter 2: Architecture Principles for Player and Referee Agents
% עקרונות ארכיטקטוניים לסוכן השחקן והשופט
% Teaches students how to apply LGM architectural patterns to their agents
% =============================================================================

\documentclass[../master/main.tex]{subfiles}

\begin{document}

\setcounter{chapter}{1}
\hebrewchapter{עקרונות ארכיטקטוניים לסוכן}
\hebrewchapterlabel{chap:architecture-principles}

\par\needspace{5\baselineskip}
\hebrewsection{מבוא}

פרק זה מציג את העקרונות הארכיטקטוניים שעל הסטודנטים ליישם בסוכן השחקן והשופט שלהם. העקרונות מבוססים על אותן תבניות שמנהל הליגה משתמש בהן (ראו נספח~ח'), אך מותאמים לצרכים הייחודיים של סוכן בודד.

\needspace{10\baselineskip}
\begin{notebox}[\hebtitle{הבדל מהותי}]
מנהל הליגה מנהל \num{30} קבוצות ו-\num{60} משחקים במקביל. הסוכן שלכם מנהל שחקן \textbf{אחד} או שופט \textbf{אחד}. זה משנה את סדרי הגודל אך לא את העקרונות.
\end{notebox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{תבנית ה-\en{Orchestrator} (שער הכניסה)}
\label{sec:agent-orchestrator}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{הרעיון המרכזי}

ה-\en{Orchestrator} הוא הרכיב המרכזי שמתאם את כל פעילות הסוכן. הוא משמש כ\textbf{שער כניסה יחיד} לכל האינטראקציות עם העולם החיצון.

\begin{fancytable}{lHH}{תפקידי ה-\en{Orchestrator}}
\label{tab:orchestrator-responsibilities}
תפקיד & תיאור & דוגמה \\
אתחול & הקמת כל תתי-המערכות & יצירת חיבור ל-\en{Gmail API} \\
תיאום & ניהול זרימת המידע & העברת הודעה ל-\en{Router} \\
ניטור & מעקב אחר תקינות & בדיקת \en{Watchdog} \\
סיום & כיבוי מסודר & שחרור משאבים \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{מבנה מומלץ}

\begin{english}
\begin{pythonbox}[PlayerOrchestrator --- Basic Structure]
class PlayerOrchestrator:
    """Central coordinator for the player agent."""

    def __init__(self, config: Config):
        self.config = config
        self.state_machine = PlayerStateMachine()
        self.rate_limiter = TokenBucketRateLimiter(
            capacity=5, refill_rate=1.0
        )
        self.message_router = MessageRouter()
        self.gmail_client = None
        self._running = False

    def start(self) -> None:
        """Initialize and start the agent."""
        self._setup_gmail_client()
        self._register_handlers()
        self._running = True
        self._run_main_loop()

    def stop(self) -> None:
        """Graceful shutdown."""
        self._running = False
        self._cleanup_resources()
\end{pythonbox}
\end{english}

\par\needspace{4\baselineskip}
\hebrewsubsection{עקרון ההפרדה}

ה-\en{Orchestrator} לא מבצע לוגיקה עסקית בעצמו --- הוא רק \textbf{מתאם} בין רכיבים:

\begin{itemize}
    \item \textbf{קבלת הודעה} $\rightarrow$ העברה ל-\en{MessageRouter}
    \item \textbf{שינוי מצב} $\rightarrow$ העברה ל-\en{StateMachine}
    \item \textbf{שליחת הודעה} $\rightarrow$ העברה דרך \en{RateLimiter}
\end{itemize}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מכונת מצבים לסוכן}
\label{sec:agent-state-machine}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{מצבי השחקן}

הסוכן עובר בין מצבים מוגדרים היטב. כל מצב קובע אילו פעולות מותרות:

\begin{fancytable}{lHH}{מצבי סוכן השחקן}
\label{tab:player-states}
מצב & תיאור & פעולות מותרות \\
\en{INIT} & אתחול ראשוני & טעינת תצורה \\
\en{REGISTERING} & בתהליך הרשמה & שליחת בקשת הרשמה \\
\en{REGISTERED} & רשום לעונה & המתנה להקצאות \\
\en{AWAITING} & ממתין להזמנה & קבלת הזמנות למשחק \\
\en{INVITED} & הוזמן למשחק & אישור/דחיית הזמנה \\
\en{IN\_MATCH} & במהלך משחק & ביצוע מהלכים \\
\en{PAUSED} & מושהה & המתנה להמשך \\
\en{ERROR} & שגיאה & ניסיון התאוששות \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{תרשים מעברים}

\begin{figure}[htbp]
\centering
\begin{english}
\begin{tikzpicture}[
    node distance=2cm,
    state/.style={rectangle, rounded corners, draw=black, fill=blue!10,
                  minimum width=2cm, minimum height=0.8cm, font=\small},
    arrow/.style={->, thick, >=stealth}
]
    \node[state] (init) {INIT};
    \node[state, right=of init] (reg) {REGISTERING};
    \node[state, right=of reg] (regd) {REGISTERED};
    \node[state, below=of regd] (await) {AWAITING};
    \node[state, left=of await] (invite) {INVITED};
    \node[state, left=of invite] (match) {IN\_MATCH};

    \draw[arrow] (init) -- node[above, font=\tiny] {start} (reg);
    \draw[arrow] (reg) -- node[above, font=\tiny] {confirmed} (regd);
    \draw[arrow] (regd) -- node[right, font=\tiny] {table} (await);
    \draw[arrow] (await) -- node[above, font=\tiny] {invite} (invite);
    \draw[arrow] (invite) -- node[above, font=\tiny] {accept} (match);
    \draw[arrow] (match) to[bend left=30] node[below, font=\tiny] {complete} (await);
\end{tikzpicture}
\end{english}
\caption{מעברי מצבים בסוכן השחקן}
\label{fig:player-state-transitions}
\end{figure}

\par\needspace{4\baselineskip}
\hebrewsubsection{יישום מכונת המצבים}

\begin{english}
\begin{pythonbox}[Basic State Machine]
from enum import Enum, auto
from typing import Dict, Set, Callable

class PlayerState(Enum):
    INIT = auto()
    REGISTERING = auto()
    REGISTERED = auto()
    AWAITING = auto()
    INVITED = auto()
    IN_MATCH = auto()
    PAUSED = auto()
    ERROR = auto()

class PlayerStateMachine:
    # Valid state transitions
    TRANSITIONS: Dict[PlayerState, Set[PlayerState]] = {
        PlayerState.INIT: {PlayerState.REGISTERING},
        PlayerState.REGISTERING: {PlayerState.REGISTERED, PlayerState.ERROR},
        PlayerState.REGISTERED: {PlayerState.AWAITING},
        PlayerState.AWAITING: {PlayerState.INVITED, PlayerState.PAUSED},
        PlayerState.INVITED: {PlayerState.IN_MATCH, PlayerState.AWAITING},
        PlayerState.IN_MATCH: {PlayerState.AWAITING, PlayerState.ERROR},
    }

    def __init__(self):
        self._state = PlayerState.INIT
        self._callbacks: Dict[PlayerState, Callable] = {}

    def transition_to(self, new_state: PlayerState) -> bool:
        """Attempt state transition. Returns success."""
        if new_state not in self.TRANSITIONS.get(self._state, set()):
            return False
        self._state = new_state
        if callback := self._callbacks.get(new_state):
            callback()
        return True
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{תבנית ה-\en{GateKeeper} (הגנת אימייל)}
\label{sec:agent-gatekeeper}
% =============================================================================

\needspace{10\baselineskip}
\begin{warningbox}[\hebtitle{דרישה קריטית}]
\textbf{כל סוכן (שחקן ושופט) חייב לממש מנגנון \en{GateKeeper} להגנה על מכסות ה-\en{Gmail API}.} סוכן ללא הגנה עלול לצרוך את כל המכסה היומית ולהפסיק לתפקד.
\end{warningbox}

\par\needspace{4\baselineskip}
\hebrewsubsection{שלושת רכיבי ה-\en{GateKeeper}}

הסוכן שלכם צריך לממש שלושה מנגנוני הגנה:

\begin{fancytable}{lHH}{רכיבי ה-\en{GateKeeper}}
\label{tab:gatekeeper-components}
רכיב & תפקיד & ערכים מומלצים \\
\en{Quota Manager} & מעקב מכסה יומית & \num{400} הודעות/יום, אזהרה ב-\num{80}\% \\
\en{Rate Limiter} & מגביל קצב שליחה & \num{5} אסימונים, מילוי \num{1}/שנייה \\
\en{DOS Detector} & זיהוי לולאות אינסופיות & מקסימום \num{2} הודעות/דקה לאותו נמען \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{מנהל מכסה (\en{Quota Manager})}

\en{Gmail API} מגביל חשבונות חינמיים ל-\num{500} הודעות ליום. השאירו מרווח ביטחון:

\begin{english}
\begin{pythonbox}[QuotaManager --- Daily Email Limit]
class QuotaManager:
    """Track daily email quota."""

    def __init__(self, daily_limit: int = 400, warning_threshold: float = 0.8):
        self.daily_limit = daily_limit
        self.warning_threshold = warning_threshold
        self._count = 0
        self._last_reset = datetime.now(timezone.utc).date()

    def can_send(self) -> bool:
        """Check if we can send more emails today."""
        self._maybe_reset()
        return self._count < self.daily_limit

    def record_send(self) -> None:
        """Record an outgoing email."""
        self._maybe_reset()
        self._count += 1
        if self._count >= self.daily_limit * self.warning_threshold:
            logger.warning(f"Quota warning: {self._count}/{self.daily_limit}")

    def _maybe_reset(self) -> None:
        """Reset counter at midnight GMT."""
        today = datetime.now(timezone.utc).date()
        if today > self._last_reset:
            self._count = 0
            self._last_reset = today
\end{pythonbox}
\end{english}

\par\needspace{4\baselineskip}
\hebrewsubsection{זיהוי לולאות (\en{DOS Self-Protection})}

הסוכן עלול להיכנס ללולאה אינסופית של שליחת הודעות. הוסיפו הגנה:

\begin{english}
\begin{pythonbox}[DOS Detector --- Prevent Runaway Loops]
class DOSDetector:
    """Detect runaway message loops."""

    def __init__(self, max_per_minute: int = 2):
        self.max_per_minute = max_per_minute
        self._recent_sends: dict[str, list[datetime]] = {}

    def is_safe_to_send(self, recipient: str) -> bool:
        """Check if sending to this recipient is safe."""
        now = datetime.now(timezone.utc)
        cutoff = now - timedelta(minutes=1)

        # Clean old entries
        if recipient in self._recent_sends:
            self._recent_sends[recipient] = [
                t for t in self._recent_sends[recipient] if t > cutoff
            ]

        # Check rate
        recent = self._recent_sends.get(recipient, [])
        return len(recent) < self.max_per_minute

    def record_send(self, recipient: str) -> None:
        """Record a send to recipient."""
        if recipient not in self._recent_sends:
            self._recent_sends[recipient] = []
        self._recent_sends[recipient].append(datetime.now(timezone.utc))
\end{pythonbox}
\end{english}

\needspace{10\baselineskip}
\begin{notebox}[\hebtitle{למה זה חשוב?}]
באג בקוד שלכם יכול לגרום לשליחת מאות הודעות בדקות ספורות. זה יגרום:
\begin{itemize}
    \item מיצוי מכסת האימייל היומית
    \item חסימה זמנית על ידי \en{Gmail}
    \item הפסדים טכניים בכל המשחקים שנותרו
\end{itemize}
\end{notebox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מגביל קצב (\en{Token Bucket Rate Limiter})}
\label{sec:agent-rate-limiter}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{הבעיה}

\en{Gmail API} מגביל את מספר הקריאות. חריגה גורמת לשגיאת \en{429 Too Many Requests} וחסימה זמנית.

\par\needspace{4\baselineskip}
\hebrewsubsection{הפתרון}

אלגוריתם \en{Token Bucket} מאפשר שליטה חלקה בקצב:

\begin{enumerate}
    \item \textbf{דלי אסימונים} --- מכיל עד $N$ אסימונים (למשל, \num{5})
    \item \textbf{מילוי} --- אסימון חדש כל $T$ שניות (למשל, כל שנייה)
    \item \textbf{צריכה} --- כל קריאת \en{API} צורכת אסימון אחד
    \item \textbf{המתנה} --- אם אין אסימונים, ממתינים למילוי
\end{enumerate}

\begin{english}
\begin{pythonbox}[TokenBucketRateLimiter Implementation]
import time
import threading

class TokenBucketRateLimiter:
    """Thread-safe token bucket rate limiter."""

    def __init__(self, capacity: int = 5, refill_rate: float = 1.0):
        self.capacity = capacity
        self.tokens = capacity
        self.refill_rate = refill_rate  # tokens per second
        self.last_refill = time.monotonic()
        self._lock = threading.Lock()

    def acquire(self, timeout: float = 30.0) -> bool:
        """Acquire a token. Blocks until available or timeout."""
        deadline = time.monotonic() + timeout

        while time.monotonic() < deadline:
            with self._lock:
                self._refill()
                if self.tokens >= 1:
                    self.tokens -= 1
                    return True
            time.sleep(0.1)

        return False

    def _refill(self) -> None:
        """Add tokens based on elapsed time."""
        now = time.monotonic()
        elapsed = now - self.last_refill
        new_tokens = elapsed * self.refill_rate
        self.tokens = min(self.capacity, self.tokens + new_tokens)
        self.last_refill = now
\end{pythonbox}
\end{english}

\needspace{10\baselineskip}
\begin{notebox}[\hebtitle{המלצה}]
התחילו עם קיבולת של \num{5} אסימונים וקצב מילוי של אסימון לשנייה. התאימו לפי הצורך.
\end{notebox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מערכת תזמון (\en{Periodic Handler})}
\label{sec:agent-periodic-handler}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{שני לולאות עיקריות}

הסוכן צריך לבצע פעולות תקופתיות:

\begin{fancytable}{lHH}{לולאות תזמון}
\label{tab:periodic-loops}
לולאה & תדירות & תפקיד \\
\en{Poll Loop} & כל \num{30} שניות & בדיקת הודעות חדשות \\
\en{Heartbeat Loop} & כל \num{5} דקות & שליחת סימן חיים \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{יישום}

\begin{english}
\begin{pythonbox}[PeriodicHandler with Event]
import threading
from typing import Callable

class PeriodicHandler:
    """Manages periodic tasks with graceful shutdown."""

    def __init__(self):
        self._stop_event = threading.Event()
        self._threads: list[threading.Thread] = []

    def add_task(self, func: Callable, interval: float, name: str):
        """Add a periodic task."""
        def runner():
            while not self._stop_event.wait(interval):
                try:
                    func()
                except Exception as e:
                    print(f"Error in {name}: {e}")

        thread = threading.Thread(target=runner, name=name, daemon=True)
        self._threads.append(thread)

    def start(self):
        """Start all periodic tasks."""
        for thread in self._threads:
            thread.start()

    def stop(self, timeout: float = 5.0):
        """Signal all tasks to stop and wait."""
        self._stop_event.set()
        for thread in self._threads:
            thread.join(timeout=timeout)
\end{pythonbox}
\end{english}

\needspace{10\baselineskip}
\begin{protocolbox}[width=\textwidth]
\textbf{עיקרון חשוב:} השתמשו ב-\en{Event.wait()} ולא ב-\en{time.sleep()} --- זה מאפשר כיבוי מהיר ומסודר.
\end{protocolbox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{ניתוב הודעות (\en{Message Router})}
\label{sec:agent-message-router}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{תבנית הרישום}

במקום \en{if-else} ארוך לטיפול בסוגי הודעות, השתמשו בתבנית רישום:

\begin{english}
\begin{pythonbox}[MessageRouter with Handler Registration]
from typing import Dict, Callable, Any
from enum import Enum

class MessageType(Enum):
    REGISTRATION_CONFIRMED = "REGISTRATION_CONFIRMED"
    GAME_INVITATION = "GAME_INVITATION"
    MOVE_REQUEST = "MOVE_REQUEST"
    GAME_RESULT = "GAME_RESULT"
    BROADCAST_KEEP_ALIVE = "BROADCAST_KEEP_ALIVE"

class MessageRouter:
    """Routes messages to registered handlers."""

    def __init__(self):
        self._handlers: Dict[MessageType, Callable] = {}

    def register(self, msg_type: MessageType, handler: Callable):
        """Register a handler for a message type."""
        self._handlers[msg_type] = handler

    def route(self, message: Dict[str, Any]) -> bool:
        """Route message to appropriate handler."""
        msg_type_str = message.get("message_type")
        try:
            msg_type = MessageType(msg_type_str)
        except ValueError:
            return False  # Unknown message type

        handler = self._handlers.get(msg_type)
        if handler:
            handler(message)
            return True
        return False
\end{pythonbox}
\end{english}

\par\needspace{4\baselineskip}
\hebrewsubsection{יתרונות התבנית}

\begin{itemize}
    \item \textbf{הרחבה קלה} --- הוספת סוג הודעה חדש = רישום מטפל חדש
    \item \textbf{בדיקות} --- קל לבדוק כל מטפל בנפרד
    \item \textbf{קריאות} --- ברור מי מטפל במה
\end{itemize}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{איחוד הודעות באמצעות \en{CC}}
\label{sec:agent-cc-consolidation}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{העיקרון}

במקום לשלוח מספר הודעות נפרדות, השתמשו בשדה \en{CC} לאיחוד:

\begin{fancytable}{lHH}{שימוש בשדות נמען}
\label{tab:cc-usage}
שדה & נמען & תפקיד \\
\en{TO} & מנהל הליגה & הנמען העיקרי \\
\en{CC} & שרת הלוג & תיעוד אוטומטי \\
\en{CC} & חברי קבוצה & שקיפות \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{דוגמה --- שליחת מהלך}

\begin{english}
\begin{pythonbox}[Sending with CC]
def send_move(self, game_id: str, move: str) -> None:
    """Send move to LGM with CC to log server and group."""
    message = self._build_move_message(game_id, move)

    recipients = {
        "to": [self.config.lgm_email],
        "cc": [
            self.config.log_server_email,
            *self._get_group_emails()
        ]
    }

    self.gmail_client.send(
        to=recipients["to"],
        cc=recipients["cc"],
        subject=self._build_subject(game_id),
        body=json.dumps(message)
    )
\end{pythonbox}
\end{english}

\needspace{10\baselineskip}
\begin{notebox}[\hebtitle{חיסכון ב-\en{API}}]
שליחה אחת עם \en{CC} צורכת קריאת \en{API} \textbf{אחת}, במקום שלוש קריאות נפרדות.
\end{notebox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{מנגנון \en{Watchdog}}
\label{sec:agent-watchdog}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{הבעיה}

לולאת הסריקה עלולה להיתקע (\en{stall}) בגלל:
\begin{itemize}
    \item תקלת רשת
    \item חריגה לא מטופלת
    \item \en{deadlock}
\end{itemize}

\par\needspace{4\baselineskip}
\hebrewsubsection{הפתרון}

\begin{english}
\begin{pythonbox}[Watchdog Implementation]
import time
import threading

class Watchdog:
    """Detects stalled operations."""

    def __init__(self, timeout: float = 120.0, callback: Callable = None):
        self.timeout = timeout
        self.callback = callback
        self._last_ping = time.monotonic()
        self._lock = threading.Lock()
        self._running = True
        self._thread = threading.Thread(target=self._monitor, daemon=True)

    def ping(self):
        """Call this regularly to indicate activity."""
        with self._lock:
            self._last_ping = time.monotonic()

    def _monitor(self):
        """Background monitor thread."""
        while self._running:
            time.sleep(10)  # Check every 10 seconds
            with self._lock:
                elapsed = time.monotonic() - self._last_ping
            if elapsed > self.timeout and self.callback:
                self.callback()

    def start(self):
        self._thread.start()

    def stop(self):
        self._running = False
\end{pythonbox}
\end{english}

\par\needspace{4\baselineskip}
\hebrewsubsection{שימוש}

\begin{english}
\begin{pythonbox}[Watchdog in Main Loop]
def _run_main_loop(self):
    watchdog = Watchdog(
        timeout=120.0,
        callback=self._handle_stall
    )
    watchdog.start()

    while self._running:
        watchdog.ping()  # Signal activity
        messages = self._poll_for_messages()
        for msg in messages:
            self.message_router.route(msg)
        time.sleep(30)
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{תבנית מעקב מועדים (\en{Deadline Tracker})}
\label{sec:agent-deadline-tracker}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{הבעיה}

אם הסוכן לא מגיב בזמן, התגובה תידחה והוא יקבל הודעת \en{REJECTION\_NOTIFICATION}. עליכם לעקוב אחר מועדי התגובה.

\begin{english}
\begin{pythonbox}[DeadlineTracker --- Track Response Deadlines]
from dataclasses import dataclass
from datetime import datetime, timezone

@dataclass
class PendingResponse:
    message_id: str
    message_type: str
    deadline: datetime
    correlation_id: str

class DeadlineTracker:
    """Track pending responses and their deadlines."""

    def __init__(self):
        self._pending: dict[str, PendingResponse] = {}

    def add_pending(self, message_id: str, message_type: str,
                    deadline: datetime, correlation_id: str) -> None:
        """Track a message requiring response."""
        self._pending[message_id] = PendingResponse(
            message_id=message_id,
            message_type=message_type,
            deadline=deadline,
            correlation_id=correlation_id
        )

    def get_urgent(self) -> list[PendingResponse]:
        """Get messages with deadline in next 30 seconds."""
        now = datetime.now(timezone.utc)
        cutoff = now + timedelta(seconds=30)
        return [p for p in self._pending.values() if p.deadline <= cutoff]

    def mark_responded(self, correlation_id: str) -> None:
        """Remove message after responding."""
        to_remove = [k for k, v in self._pending.items()
                     if v.correlation_id == correlation_id]
        for k in to_remove:
            del self._pending[k]
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{תבנית התאמת הודעות (\en{Correlation Matching})}
\label{sec:agent-correlation}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{שימוש ב-\en{correlation\_id}}

כל הודעה במערכת כוללת שדה \en{correlation\_id} המקשר בין בקשה לתגובה:

\begin{english}
\begin{pythonbox}[MessageCorrelator --- Match Requests and Responses]
class MessageCorrelator:
    """Match outgoing requests with incoming responses."""

    def __init__(self):
        self._open_requests: dict[str, dict] = {}

    def track_request(self, correlation_id: str, request: dict) -> None:
        """Track an outgoing request."""
        self._open_requests[correlation_id] = {
            "request": request,
            "sent_at": datetime.now(timezone.utc),
            "status": "OPEN"
        }

    def match_response(self, correlation_id: str, response: dict) -> dict:
        """Match response to original request."""
        if correlation_id not in self._open_requests:
            return None

        entry = self._open_requests[correlation_id]
        entry["response"] = response
        entry["received_at"] = datetime.now(timezone.utc)
        entry["status"] = "CLOSED"
        return entry["request"]

    def get_open_requests(self) -> list[str]:
        """Get all open correlation IDs."""
        return [k for k, v in self._open_requests.items()
                if v["status"] == "OPEN"]
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{טיפול בשידורים (\en{Broadcast Handling})}
\label{sec:agent-broadcast-handling}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{\num{11} סוגי שידורים}

מנהל הליגה שולח הודעות שידור לכל המשתתפים. חלקן דורשות תגובה:

\begin{fancytable}{lHcH}{סוגי שידורים ותגובה נדרשת}
\label{tab:broadcast-types}
סוג & תיאור & תגובה? & מועד \\
\en{BROADCAST\_KEEP\_ALIVE} & בדיקת זמינות & כן & \en{30s} \\
\en{BROADCAST\_CRITICAL\_RESET} & איפוס מערכת & כן & \en{2m} \\
\en{BROADCAST\_CRITICAL\_PAUSE} & השהיית פעילות & כן & \en{2m} \\
\en{BROADCAST\_CRITICAL\_CONTINUE} & המשך פעילות & כן & \en{2m} \\
\en{BROADCAST\_FREE\_TEXT} & הודעה חופשית & אופציונלי & \en{1h} \\
\en{BROADCAST\_NEW\_LEAGUE\_ROUND} & תחילת מחזור & לא & --- \\
\en{BROADCAST\_END\_LEAGUE\_ROUND} & סיום מחזור & לא & --- \\
\en{BROADCAST\_START\_SEASON} & תחילת עונה & לא & --- \\
\en{BROADCAST\_END\_SEASON} & סיום עונה & לא & --- \\
\en{BROADCAST\_ASSIGNMENT\_TABLE} & טבלת הקצאות & לא & --- \\
\en{BROADCAST\_ROUND\_RESULTS} & תוצאות מחזור & לא & --- \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{יישום מטפל שידורים}

\begin{english}
\begin{pythonbox}[BroadcastHandler --- Complete Implementation]
class BroadcastHandler:
    """Handles league-wide broadcast messages."""

    # Broadcasts that require response
    RESPONSE_REQUIRED = {
        "BROADCAST_KEEP_ALIVE": ("RESPONSE_KEEP_ALIVE", 30),
        "BROADCAST_CRITICAL_RESET": ("RESPONSE_CRITICAL_RESET", 120),
        "BROADCAST_CRITICAL_PAUSE": ("RESPONSE_CRITICAL_PAUSE", 120),
        "BROADCAST_CRITICAL_CONTINUE": ("RESPONSE_CRITICAL_CONTINUE", 120),
    }

    def __init__(self, state_machine: PlayerStateMachine):
        self.state_machine = state_machine
        self._previous_state = None

    def handle(self, message: dict) -> dict | None:
        """Route broadcast to appropriate handler."""
        msg_type = message.get("message_type")

        if msg_type == "BROADCAST_KEEP_ALIVE":
            return self._handle_keep_alive(message)
        elif msg_type == "BROADCAST_CRITICAL_PAUSE":
            return self._handle_pause(message)
        elif msg_type == "BROADCAST_CRITICAL_CONTINUE":
            return self._handle_continue(message)
        elif msg_type in ("BROADCAST_NEW_LEAGUE_ROUND",
                          "BROADCAST_END_LEAGUE_ROUND"):
            self._update_round_state(message)
            return None  # No response required
        return None

    def _handle_keep_alive(self, message: dict) -> dict:
        """Respond to keep-alive with current state."""
        return {
            "message_type": "RESPONSE_KEEP_ALIVE",
            "broadcast_id": message.get("broadcast_id"),
            "machine_state": self.state_machine.current_state.name
        }
\end{pythonbox}
\end{english}

\needspace{8\baselineskip}
\begin{notebox}[\hebtitle{זיהוי שידור}]
ניתן לזהות הודעת שידור לפי:
\begin{itemize}
    \item סוג ההודעה מתחיל ב-\en{BROADCAST\_}
    \item קיים שדה \en{broadcast\_id} בתוכן ההודעה
    \item נשלחה מכתובת מנהל הליגה
\end{itemize}
\end{notebox}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{ניהול תצורה}
\label{sec:agent-configuration}
% =============================================================================

\par\needspace{4\baselineskip}
\hebrewsubsection{הפרדת סודות מהגדרות}

\begin{fancytable}{lHH}{הפרדת קבצי תצורה}
\label{tab:config-separation}
קובץ & תוכן & ב-\en{Git}? \\
\en{.env} & סודות (סיסמאות, מפתחות) & \textbf{לא} \\
\en{config.json} & הגדרות (כתובות, פרמטרים) & כן \\
\end{fancytable}

\par\needspace{4\baselineskip}
\hebrewsubsection{קובץ סודות}

\begin{english}
\begin{pythonbox}[.env File]
# Gmail API credentials
GMAIL_CLIENT_ID=your-client-id.apps.googleusercontent.com
GMAIL_CLIENT_SECRET=your-client-secret
GMAIL_REFRESH_TOKEN=your-refresh-token

# Database
DATABASE_URL=postgresql://user:pass@localhost/league
\end{pythonbox}
\end{english}

\par\needspace{4\baselineskip}
\hebrewsubsection{קובץ הגדרות}

\begin{english}
\begin{pythonbox}[config.json File]
{
  "agent": {
    "player_id": "P-Q21G-001",
    "group_id": "G001"
  },
  "gmail": {
    "poll_interval_seconds": 30,
    "rate_limit_capacity": 5,
    "rate_limit_refill_rate": 1.0
  },
  "lgm": {
    "email": "league.manager.q21g@gmail.com",
    "log_server_email": "beit.halevi.700@gmail.com"
  },
  "watchdog": {
    "timeout_seconds": 120
  }
}
\end{pythonbox}
\end{english}

% =============================================================================
\par\needspace{5\baselineskip}
\hebrewsection{סיכום}
% =============================================================================

פרק זה הציג את העקרונות הארכיטקטוניים ליישום סוכן שחקן או שופט:

\begin{itemize}
    \item \textbf{\en{Orchestrator}} --- שער כניסה יחיד לתיאום כל הפעילות
    \item \textbf{מכונת מצבים} --- ניהול מעברים בין מצבים מוגדרים
    \item \textbf{\en{Token Bucket}} --- שליטה בקצב קריאות \en{API}
    \item \textbf{\en{Periodic Handler}} --- ביצוע פעולות תקופתיות עם כיבוי מסודר
    \item \textbf{\en{Message Router}} --- ניתוב הודעות למטפלים רשומים
    \item \textbf{איחוד \en{CC}} --- חיסכון בקריאות \en{API} ושקיפות
    \item \textbf{\en{Watchdog}} --- זיהוי והתאוששות מתקיעות
    \item \textbf{טיפול בשידורים} --- תגובה להודעות מערכתיות
    \item \textbf{הפרדת תצורה} --- סודות ב-\en{.env}, הגדרות ב-\en{config.json}
\end{itemize}

\needspace{10\baselineskip}
\begin{protocolbox}[width=\textwidth]
\textbf{המלצה:} התחילו ביישום פשוט של כל רכיב, ושפרו בהדרגה. אל תנסו לבנות הכל מושלם מההתחלה.
\end{protocolbox}

לרקע על הארכיטקטורה המקבילה של מנהל הליגה, ראו נספח~ח'.

\end{document}
